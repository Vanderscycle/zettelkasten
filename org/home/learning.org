* Learning Notes
** silver searcher
   :PROPERTIES:
   :END:
*** search, find and replace                                          :linux:
#+begin_src bash
ag -l <search-word> | xargs sed -i '' 's/<search-word>/<replace-word>/g'
#+end_src
explanation
~ag -l~ list all the files where the word is found
~xargs~ linux for loop
~sed -i~ replace the word in place
** nixos
   :PROPERTIES:
   :END:
*** generations                                                       :linux:
    list all generations
#+begin_src bash
sudo nix-env --list-generations --profile /nix/var/nix/profiles/system
#+end_src
    switch to an old one and delete a specific one (using 123 - 124)
#+begin_src
sudo nix-env --switch-generation 123 --profile /nix/var/nix/profiles/system
sudo nix-env --delete-generation 124 --profile /nix/var/nix/profiles/system
#+end_src
    delete all generations except the current one
#+begin_src bash
sudo nix-env --delete-generations old --profile /nix/var/nix/profiles/system
#+end_src

** git
   :PROPERTIES:
   :END:
*** remote branch
Sometimes a branch have a complex pull/push will not allow for a ~git reset --hard <branch-name>~. Deleting the branch and refetching may work better.
#+begin_src bash
git fetch <branch-name>
#+end_src

** format brand new ssd
   :PROPERTIES:
   :END:
*** format                                                            :linux:
    Verify status
#+begin_src bash
# identify the drive
lsblk
sudo blkid <e.g. /dev/sda>
# if empty means that it isn't formatted
#+end_src
    Create a partition (for unformatted drives/usbs)
#+begin_src bash
# Create a new GPT partition table
sudo parted /dev/sda -- mklabel gpt

# Create a new partition that uses the whole disk
sudo parted /dev/sda -- mkpart primary ext4 0% 100%

# Format the new partition
sudo mkfs.ext4 /dev/sda1
#+end_src
*** mount new drive
#+begin_src bash
sudo mount /dev/sda /mnt/usb/
# /mnt/usb is a folder I created
#+end_src

** create bootable drive for sd card/usb/harddrive
   :PROPERTIES:
   :END:
*** format                                                            :linux:
    Please confirm that you have the right drive
#+begin_src bash
sudo dd if=<img> of=/dev/sda bs=4M status=progress conv=fsync
#+end_src

** nnn
   :PROPERTIES:
   :END:
*** nnn                                                               :linux:
    sort by time/date/size etc: hit the ~t~ when in nnn

** nix
   :PROPERTIES:
   :END:
*** nix self reference parameters                                     :linux:

    We reference the ~sum-config~ not shown here is the default port of that config. Check prometheus. Regardless, you can reference config values
    #+begin_src nix
    exporters = {
      node = {
        enable = true;
      };
      sum-config = {
        enable = true;
        user = "admin";
        apiKeyFile = config.sops.secrets."path/to/sops/api_key".path;
      };
    };
    scrapeConfigs = [
    {
      job_name = "x-exporter";
      static_configs = [{
        # Target the exporter on localhost (if on same machine)
        targets = [ "127.0.0.1:${toString config.services.prometheus.exporters.sum-config.port}" ];
      }];
    }
    ];

    #+end_src

** self hosted git repo
   :PROPERTIES:
   :END:
*** adjusting the origin url                                          :linux:
    Let's say I have a gitea server running at ~gitea.homecloud.lan~

    gitea will give you a remote ssh address like so: =git remote add origin gitea@localhost:vanderscycle/dotFiles.git= you need to adjust it to:  =git remote add origin gitea@gitea.homecloud.lan:vanderscycle/dotFiles.git= or the ip address if no reverse proxy.

*** multiple remote
#+begin_src bash
git remote add <name> <address>
#+end_src

** emacs
   :PROPERTIES:
   :END:
*** bookmarks                                                         :emacs:
=C-x r m= set bookmarks
=C-x r b= jump to bookmarks
=C-x r l= bookmark handy menu
** deterministic-zip
   :PROPERTIES:
   :END:
*** hash
    the std zip package does not generate the same hash even when no modification to the file has been made. Because it takes in account the latest modification date + today's data. To ensure we have the same zip we must use ~deterministic-zip~ package.

** dockerfile not working
   :PROPERTIES:
   :END:
*** base image
Check for changes to the base image especially if the current tag is ~latest~
** serverless packaging
   :PROPERTIES:
   :END:
*** packaging
Cross check the ~package.json~ file to confirm what serverless uses to packages the application prior deploying. If you noticed a =esbuild= or the serverless plugin for it then the lambda packaging must conver the same principle.
** git (stash)
   :PROPERTIES:
   :END:
*** stash untrackted files
#+begin_src bash
git stash --include-untracked
#+end_src
** git (gha)
   :PROPERTIES:
   :END:
*** uses (branch specific)
#+begin_src yaml

deploy-fargate-enterprise-primary:
  uses: <org>/<repo>/.github/workflows/<name>.yml@testing
  with:
    key: values
#+end_src
** AWS ECR
   :PROPERTIES:
   :END:
*** fetching the env vars
login into the `AWS ECR`
pull the image

** protonmail
   :PROPERTIES:
   :END:
*** protonmail bridge                                                 :linux:
    Proton's own ~protonmail~ bridge doesn't work well and so I recommend using the open source equivalent ~hydroxide~.
    you need to auth first
#+begin_src bash
hydroxide auth <username>
#+end_src
d7rF0ARWV27VxyCxZGw3hsqxZlKp4VFFgVTwuoXFvWQ=
Then for IMAP(experimental) or SMTP services

#+begin_src bash
hydroxide smtp
#+end_src

Credentials would look something like this:
#+begin_center
Hostname: localhost
Port: 1025
Security: none
Username: your ProtonMail username
Password: the bridge password (not your ProtonMail password)
#+end_center

** user management
   :PROPERTIES:
   :END:
*** list all users                                                    :linux:
#+begin_src bash
cut -d: -f1 /etc/passwd
#+end_src

*** list all groups                                                   :linux:
#+begin_src bash
cat /etc/group
#+end_src

*** list all groups a user belong to                                  :linux:
#+begin_src bash
groups <user>
#+end_src

** systemd
   :PROPERTIES:
   :END:
*** service file                                                      :linux:
    To list all current services files on systemd you can use interactive systems like ~sysz~ or go to the file themselves.
#+begin_src bash
ls /etc/systemd/system/
# since we were looking for n8n
cat /etc/systemd/system/n8n.service
#+end_src

** nixos (FHS)
   :PROPERTIES:
   :END:
*** Filesystem Hierarchy Standard                                                                :linux:
    To list all current services files on systemd you can use interactive systems like ~sysz~ or go to the file themselves.
#+begin_src bash
ls /etc/systemd/system/
# since we were looking for n8n
cat /etc/systemd/system/n8n.service
#+end_src
FHS is a convention of files/folder location for linux for interoperability of software of various kind and source.
Because nixos doesn't respect ~FHS~ we can make a fake default path to ~/etc~ in something like this:
#+begin_src nix
environment.etc."bin/bash".source = "${pkgs.bashInteractive}/bin/bash";
# /etc/bin/bash will have the bash bin that would normally sit at /bin
#+end_src

** latex
   :PROPERTIES:
   :END:
*** build file                                                        :linux:
#+begin_src bash
pdflatex <file>.tex
#+end_src

** nixos
   :PROPERTIES:
   :END:
*** Dependencies :linux:
    ~nix why-depends~ - show why a package has another package in its closure
    #+begin_src bash
nix why-depends -a nixpkgs#orca-slicer nixpkgs#libsoup
    #+end_src
** nixos
   :PROPERTIES:
   :END:
*** env vars
    For one off runs, also ensure you use the ~--impure~ options to source env vars.
#+begin_src bash
NIXPKGS_ALLOW_INSECURE=1 nix shell nixpkgs#orca-slicer --impure
#+end_src
** nix shell
   :PROPERTIES:
   :END:
*** global typescript packages
    Using pnpm to run an init
#+begin_src bash
nix shell nixpkgs#nodejs nixpkgs#pnpm nixpkgs#nodePackages.aws-cdk --command pnpm dlx aws-cdk@latest init app --language typescript
#+end_src
* Patterns
** Zettelkasten - note taking
  :PROPERTIES:
  :CAPTURE: [2025-11-16 Sun 15:27]
  :SUBJECT: Zetterlkasten
  :END:

Steps
1. Fleeting notes (in-the-moment ideas/learning)
   - concise and unpolished.
   - capture thoughts in the moment (define the context of the moment too)
   - Use org-capture/org-roam-dailies
2. Take litterature notes (learn from reading)
   - Keep it short and selective of the idea <3 sentences
   - write in your own words
   - Literature notes can be brief annotations on a particular source (e.g. book, website or paper), that youâ€™d like to access later on.
3. Concept notes
   - Concept notes require much more care in authoring: they need to be self-explanatory and detailed
4. Take permanent notes
*** References
[[https://www.orgroam.com/manual.html][Org-roam User Manual]]
[[https://www.youtube.com/watch?v=BG1tfC7tSYw][How To Take Smart Notes - YouTube]]
